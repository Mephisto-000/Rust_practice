# Rust 中的所有權概念

[參考網址](https://rust-lang.tw/book-tw/ch04-00-understanding-ownership.html)  

所有權可以說是 Rust 最與眾不同的特色，並深深影響著整個語言。這讓 **Rust 不需要垃圾回收（garbage collector）**就可以保障記憶體安全，因此理解 Rust 中的所有權如何運作至關重要。

## 0. 記憶體管理

對於記憶體管理，我們希望程式語言提供兩種功能：

- **安全**：指標絕對不能指向已釋出的物件，這是未定義行為，會導致崩潰與安全漏洞。
- **控制**：讓記憶體能夠在我們選擇的時間迅速釋出，以便控制程式耗用的記憶體。

所有的主要的程式語言，幾乎都屬於上述其一：

- **安全優先**：使用垃圾回收來管理記憶體，當指向某個物件的指標都消失時，它們會自動釋出該物件，這種做法可以消除懸空指標，它們會保留物件直到沒有指標指向它們為止。
  Example：Python、JavaScript、Ruby、Java、C#、Haskell。
- **控制優先**：讓你自己負責釋出記憶體。程式的記憶體使用情況完全由你控制，但避免懸空指標完全由你自己來控制。

## 1. 什麼是所有權？

Rust 選擇了第三種方式：記憶體由所有權系統管理，且編譯器會在編譯時加上一些規則檢查。如果有地方違規的話，程式就無法編譯。這些所有權的規則完全不會降低執行程式的速度。

### 1-1. 堆疊（Stack）與堆積（Heap）

堆疊與堆積都是提供程式碼在執行時能夠使用的記憶體部分，但他們組成的方式卻不一樣。

1. **堆疊**：堆疊會按照取得數值的順序依序存放它們，並以相反的順序移除數值。通常稱為**後進先出（last in, first out）**。當我們要新增資料時，我們會稱呼為**推入堆疊（pushing onto the stack）**，而移除資料則是叫做**彈出堆疊（popping off the stack）**。所有在堆疊上的資料都必須是已知固定大小。在編譯時屬於未知或可能變更大小的資料必須儲存在堆積。
2. **堆積**：當你要將資料放入堆積，你得要求一定大小的空間。記憶體分配器（memory allocator）會找到一塊夠大的空位，標記為已佔用，然後回傳一個**指標（pointer）**，指著該位置的位址。這樣的過程稱為**在堆積上分配（allocating on the heap）**，或者有時直接簡稱為**分配**（allocating）就好（將數值放入堆疊不會被視為是在分配）。因為指標是固定已知的大小，所以你可以存在堆疊上。但當你要存取實際資料時，你就得去透過指標取得資料。

### 1-2. 所有權規則

- Rust 中每個數值都有個**擁有者（owner）**。
- 同時間只能有一個擁有者。
- 當擁有者離開作用域時，數值就會被丟棄。

### 1-3. 變數作用域

作為所有權的第一個範例，我們先來看變數的**作用域（scope）**。作用域是一些項目在程式內的有效範圍。假設我們有以下變數：
```rust
let s = "hello";
```

變數 `s` 是一個字串字面值（string literal），而字串數值是寫死在我們程式內。此變數的有效範圍是從它宣告開始一直到當前**作用域**結束為止。以下註解了 `s` 在哪裡有效的：
```rust
{                       // s 在此處無效，因為它還沒宣告
    let s = "hello";    // s 在此處開始視為有效
    
    // 使用 s
}                       // 此作用域結束， s 不再有效
```

換句話說，這裡有兩個重要的時間點：

- 當 `s` **進入**作用域時，它是有效的。
- 它持續被視為有效直到它**離開**作用域為止。

### 1-4. 以 String 型別為例

我們已經看過字串字面值（string literals），字串的數值是寫死在我們的程式內的。字串字面值的確很方便，但它不可能完全適用於我們使用文字時的所有狀況。**其中一個原因是因為它是不可變的**，另一個原因是並非所有字串值在我們編寫程式時就會知道。舉例來說，要是我們想要收集使用者的輸入並儲存它呢？對於這些情形，Rust 提供第二種字串型別 `String`。**此型別管理分配在堆積上的資料**，所以可以儲存我們在編譯期間未知的一些文字。
Example:

```rust
let murt s = String::from("hello");

s.push_str(", world!");  // push_str() 將字面值加到字串後面

println!("{}", s);      // 這會印出 'hello, world!'
```

所以這邊有何差別呢？為何 `String` 是可變的，但字面值卻不行？兩者最**主要的差別在於它們對待記憶體的方式**。

### 1-5. 記憶體與分配

以字串字面值來說，我們在編譯時就知道它的內容，所以可以寫死在最終執行檔內。這就是為何字串字面值非常迅速且高效。但這些特性均來自於字串字面值的不可變性。不幸的是我們無法將編譯時未知大小的文字，或是執行程式時大小可能會改變的文字等對應記憶體塞進執行檔中。

而對於 `String` 型別來說，為了要能夠支援可變性、改變文字長度大小，我們需要在堆積上分配一塊編譯時未知大小的記憶體來儲存這樣的內容，這代表：

- 記憶體分配器必須在執行時請求記憶體。
- 我們不再需要這個 `String` 時，我們需要以某種方法將此記憶體還給分配器。

當我們呼叫 `String::from` 時就等於完成第一個部分，它的實作會請求分配一塊它需要的記憶體。這邊大概和其他程式語言都一樣。

$\star$ 不過第二部分就不同了。在擁有**垃圾回收機制**（garbage collector, GC）的語言中，GC 會追蹤並清理不再使用的記憶體，所以我們不用去擔心這件事。沒有 GC 的話，識別哪些記憶體不再使用並顯式呼叫程式碼釋放它們就是我們的責任了，就像我們請求取得它一樣。在以往的歷史我們可以看到要完成這件事是一項艱鉅的任務，如果我們忘了，那麼就等於在浪費記憶體。如果我們釋放的太早的話，我們則有可能會拿到無效的變數。要是我們釋放了兩次，那也會造成程式錯誤。我們必須準確無誤地配對一個 `allocate` 給剛好一個 `free`。

Rust 選擇了一條不同的道路：當記憶體在擁有它的變數離開作用域時就會自動釋放：
```rust
{
    let s = String::from("hello"); // s 在此開始視為有效
    
    // 使用 s
}   // 此作用域結束
    // s 不再有效
```

當 `s` 離開作用域時，我們就可以很自然地將 `String` 所需要的記憶體釋放回分配器。當變數離開作用域時，Rust 會幫我們呼叫一個特殊函式。此函式叫做 [`drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop)，在這裡當時 `String` 的作者就可以寫入釋放記憶體的程式碼。Rust 會在大括號結束時自動呼叫 `drop`。
