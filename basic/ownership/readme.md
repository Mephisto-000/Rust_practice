# Rust 中的所有權概念

[參考網址](https://rust-lang.tw/book-tw/ch04-00-understanding-ownership.html)  

所有權可以說是 Rust 最與眾不同的特色，並深深影響著整個語言。這讓 **Rust 不需要垃圾回收（garbage collector）**就可以保障記憶體安全，因此理解 Rust 中的所有權如何運作至關重要。

## 0. 記憶體管理

對於記憶體管理，我們希望程式語言提供兩種功能：

- **安全**：指標絕對不能指向已釋出的物件，這是未定義行為，會導致崩潰與安全漏洞。
- **控制**：讓記憶體能夠在我們選擇的時間迅速釋出，以便控制程式耗用的記憶體。

所有的主要的程式語言，幾乎都屬於上述其一：

- **安全優先**：使用垃圾回收來管理記憶體，當指向某個物件的指標都消失時，它們會自動釋出該物件，這種做法可以消除懸空指標，它們會保留物件直到沒有指標指向它們為止。
  Example：Python、JavaScript、Ruby、Java、C#、Haskell。
- **控制優先**：讓你自己負責釋出記憶體。程式的記憶體使用情況完全由你控制，但避免懸空指標完全由你自己來控制。

## 1. 什麼是所有權？

Rust 選擇了第三種方式：記憶體由所有權系統管理，且編譯器會在編譯時加上一些規則檢查。如果有地方違規的話，程式就無法編譯。這些所有權的規則完全不會降低執行程式的速度。

### 1-1. 堆疊（Stack）與堆積（Heap）

堆疊與堆積都是提供程式碼在執行時能夠使用的記憶體部分，但他們組成的方式卻不一樣。

1. **堆疊**：堆疊會按照取得數值的順序依序存放它們，並以相反的順序移除數值。通常稱為**後進先出（last in, first out）**。當我們要新增資料時，我們會稱呼為**推入堆疊（pushing onto the stack）**，而移除資料則是叫做**彈出堆疊（popping off the stack）**。所有在堆疊上的資料都必須是已知固定大小。在編譯時屬於未知或可能變更大小的資料必須儲存在堆積。
2. **堆積**：當你要將資料放入堆積，你得要求一定大小的空間。記憶體分配器（memory allocator）會找到一塊夠大的空位，標記為已佔用，然後回傳一個**指標（pointer）**，指著該位置的位址。這樣的過程稱為**在堆積上分配（allocating on the heap）**，或者有時直接簡稱為**分配**（allocating）就好（將數值放入堆疊不會被視為是在分配）。因為指標是固定已知的大小，所以你可以存在堆疊上。但當你要存取實際資料時，你就得去透過指標取得資料。

### 1-2. 所有權規則

- Rust 中每個數值都有個**擁有者（owner）**。
- 同時間只能有一個擁有者。
- 當擁有者離開作用域時，數值就會被丟棄。

### 1-3. 變數作用域

作為所有權的第一個範例，我們先來看變數的**作用域（scope）**。作用域是一些項目在程式內的有效範圍。假設我們有以下變數：
```rust
let s = "hello";
```

變數 `s` 是一個字串字面值（string literal），而字串數值是寫死在我們程式內。此變數的有效範圍是從它宣告開始一直到當前**作用域**結束為止。以下註解了 `s` 在哪裡有效的：
```rust
{                       // s 在此處無效，因為它還沒宣告
    let s = "hello";    // s 在此處開始視為有效
    
    // 使用 s
}                       // 此作用域結束， s 不再有效
```

換句話說，這裡有兩個重要的時間點：

- 當 `s` **進入**作用域時，它是有效的。
- 它持續被視為有效直到它**離開**作用域為止。

### 1-4. 以 String 型別為例

