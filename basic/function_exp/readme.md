# 函式

[參考網址](https://rust-lang.tw/book-tw/ch03-03-how-functions-work.html)  

Rust 程式碼使用 *snake case* 式作為函式與變數名稱的慣例風格。所有的字母都是小寫，並用底線區隔單字。以下是一支包含函式定義範例的程式：

```rust
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("另一支函式。");
}
```

我們在 Rust 中定義函式是先從 `fn` 開始，再加上函式名稱和一組括號，大括號告訴編譯器函式本體的開始與結束位置。

## 1. 參數（parameters）

我們也可以定義函式成擁有**參數（parameters）的，這是函式簽名（signatures）中特殊的變數。當函式有參數時，你可以提供那些參數的確切數值。嚴格上來說，我們傳遞的數值會叫做引數（arguments）**。

Example:
```rust
fn main() {

    function_1(7);

}

fn function_1(x: i32) {
    println!("x 的數值為：{x}");
}
```

在函式簽名中，你**必須**宣告每個參數的型別，這是 Rust 刻意做下的設計決定：在函式定義中要求型別詮釋，代表編譯器幾乎不需要你在其他地方再提供資訊才能知道你要使用什麼型別。而且如果編譯器能知道函式預期的型別的話，它還能夠給予更有幫助的錯誤訊息。

如果要定義函式擁有數個參數時，會用逗號區隔開來，像這樣：
```rust
fn main() {

    function_2(77, 'L');

}

fn function_2(x: i32, unit_label: char) {
    println!("代號為：{unit_label}，數值為：{x}");
}
```

此範例建立了一個有兩個參數的函式 `function_2`，第一個參數叫做 `x` 而型別爲 `i32`，第二個參數叫做 `unit_label` 而型別爲 `char`。接著函式會印出包含 `x` 與 `unit_label` 的文字。

## 2. 陳述式（statements）與表達式（expressions）

函式本體是由一系列的陳述式（statements）並在最後可以選擇加上表達式（expression）來組成。目前我們只講了沒有用到表達式做結尾的函式。由於 **Rust 是門基於表達式（expression-based）的語言**，知道這樣的區別是很重要的。其他語言通常沒有這樣的區別，所以現在讓我們來看看陳述式和表達式有什麼不同，以及它們怎麼影響函式本體。

- **陳述式**（Statements）是進行一些動作的指令，且不回傳任何數值。
- **表達式**（Expressions）則是計算並產生數值。

建立一個變數然後用 `let` 關鍵字賦值給它就是一道陳述式：
```rust
fn main() {
    let y = 6;
}
```

上方例子中的 `let y = 6;` 就是個陳述式。陳述式不會回傳數值，因此你無法將 `let` 陳述式賦值給其他變數。

表達式則會運算出一個數值，並組合成你大部分所寫的 Rust 程式。先想想看一個數學運算比如 `5 + 6`，這就是個會算出 `11` 的表達式。表達式可以是陳述式的一部分：在上方例子中 `let y = 6;` 的 `6` 其實就是個算出 `6` 的表達式。

呼叫函式也可以是表達式、呼叫巨集也是表達式、我們用 `{}` 產生的作用域也是表達式。舉例來說：
```rust
fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!("y 的數值為：{y}");
}
```

此表達式：
```rust
{
    let x = 3;
    x + 1
}
```

就是一個會回傳 `4` 的區塊，此值再用 `let` 陳述式賦值給 `y`。請注意到 `x + 1` 這行沒有加上分號，它和你目前看到的寫法有點不同，因為**表達式結尾不會加上分號**。

## 3. 函式回傳值

函式可以回傳數值給呼叫它們的程式碼，我們不會為回傳值命名，但我們必須用箭頭（`->`）來宣告它們的型別。在 Rust 中，回傳值其實就是函式本體最後一行的表達式。你可以用 `return` 關鍵字加上一個數值來提早回傳函式。
Example:

```rust
fn main() {

    let k = function_3();
    println!("k 的數值為：{k}");

}

fn function_3() -> i32 {
    9  // 或是 return 9
}
```

在 `function_3` 函式中沒有任何函式呼叫、巨集甚至是 `let` 陳述式，只有一個 `9`。這在 Rust 中完全是合理的函式。請注意到函式的回傳型別也有指明，就是 `-> i32`。

`function_3` 中的 `9` 就是函式的回傳值，這就是為何回傳型別是 `i32`。讓我們進一步研究細節，這邊有兩個重要的地方：首先這行 `let k = function_3();` 顯示了我們用函式的回傳值作為變數的初始值。因為函式 `function_3` 回傳 `9`，所以這行和以下程式碼相同：

```rust
let k = 9;
```

再來，`function_3` 函式沒有參數但有定義回傳值的型別。所以函式本體只需有一個 `9` 就好，不需加上分號，這樣就能當做表達式回傳我們想要的數值。